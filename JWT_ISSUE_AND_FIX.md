# JWT Token Issue - Root Cause & Solution

## Problem: 403 Forbidden on Protected Endpoints

When accessing `/ticket/tickets` via the API Gateway with a valid JWT token, the request returns **403 Forbidden** even though the user is authenticated.

---

## Root Causes (2 Issues)

### Issue #1: Missing Role Claim in JWT Token

The JWT token generated by auth-service was **missing the `roles` and `userId` claims**. The old token only contained:
```json
{"sub": "admin@example.com", "iat": timestamp, "exp": timestamp}
```

The ticket-service's authentication filter tries to extract roles from the token:
```java
List<String> roles = jwtUtil.extractRoles(token);  // Returns empty!
```

Without roles, Spring Security authorization checks fail with 403.

**Fixed:** Updated JwtService to include roles and userId claims.

---

### Issue #2: Different Secret Key Decoding Between Services (CRITICAL)

Even with roles in the token, the ticket-service **could not verify the JWT signature** because it was using a different key derivation method.

**Auth-Service (CORRECT):**
```java
private Key getSignInKey() {
    byte[] keyBytes = Decoders.BASE64.decode(secretKey);  // BASE64 decode!
    return Keys.hmacShaKeyFor(keyBytes);
}
```

**Ticket-Service (INCORRECT):**
```java
private Claims extractAllClaims(String token) {
    return Jwts.parserBuilder()
            .setSigningKey(Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8)))  // WRONG!
            .build()
            .parseClaimsJws(token)
            .getBody();
}
```

**Why this breaks:**
1. JWT secret is **base64-encoded** (e.g., `dGhpc21tdmVyeXNlY3VyZWtleS4uLg==`)
2. Auth-service: Decodes base64 → `0x12345abc...` (raw bytes) → uses for signing
3. Ticket-service: Uses UTF-8 bytes of base64 string → `0x6467486d...` (different bytes!) → signature verification fails
4. Result: `isTokenValid(token)` returns `false` → 403 Forbidden

**Fixed:** Updated ticket-service JwtUtil to use BASE64 decoding like auth-service.

---

## Solutions Applied

### 1. Updated `JwtService.java` (Auth-Service)

Added new method to include role and userId claims:

```java
public String generateToken(Users user) {
    Map<String, Object> claims = Map.of(
            "userId", user.getId(),
            "roles", List.of(user.getRole().toString())
    );
    return generateToken(claims, user);
}
```

### 2. Updated `UserServiceImpl.java` (Auth-Service)

Modified login method to fetch Users entity and use new token generation:

```java
Users user = userRepository.findByEmail(request.getEmail())
        .orElseThrow(() -> new RuntimeException("User not found"));
String token = jwtService.generateToken(user);
```

### 3. Updated `JwtUtil.java` (Ticket-Service) - CRITICAL FIX

Changed secret key decoding to use BASE64 instead of UTF-8:

```java
// BEFORE (WRONG):
.setSigningKey(Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8)))

// AFTER (CORRECT):
private Key getSignInKey() {
    byte[] keyBytes = Decoders.BASE64.decode(secret);
    return Keys.hmacShaKeyFor(keyBytes);
}
```

Also updated the generateToken method to use the same key:
```java
.signWith(getSignInKey())  // Uses BASE64 decoded key
```

---

## New JWT Payload (Correct)
```json
{
  "sub": "admin@example.com",
  "userId": 1,
  "roles": ["ADMIN"],
  "iat": 1765363629,
  "exp": 1765365429
}
```

---

## How It Works Now

### Flow Diagram
```
1. User logs in via POST /auth/users/login
   ↓
2. auth-service authenticates credentials
   ↓
3. JwtService.generateToken(Users user) creates JWT:
   - Decodes secret from BASE64
   - Creates signature using decoded secret
   - Includes roles and userId claims
   ↓
4. Client sends GET /ticket/tickets with JWT
   ↓
5. ticket-service receives request:
   ↓
6. JwtAuthenticationFilter validates token:
   - Extracts JWT from Authorization header
   - JwtUtil.isTokenValid(token):
     * Decodes secret from BASE64 (SAME WAY AS AUTH-SERVICE)
     * Verifies signature ✓ NOW MATCHES!
     * Returns true
   - Extracts username from 'sub' claim
   - Extracts roles from 'roles' claim ✓ NOW PRESENT!
   - Creates SecurityContext with authorities
   ↓
7. Endpoint security checks pass:
   - .authenticated() ✓ has authorities
   - @PreAuthorize("hasRole('ADMIN')") ✓ has ROLE_ADMIN
   ↓
8. Response: 200 OK ✓
```

---

## Files Modified

| File | Change |
|------|--------|
| `auth-service/.../security/JwtService.java` | Added `generateToken(Users user)` method with role/userId claims |
| `auth-service/.../service/serviceimpl/UserServiceImpl.java` | Updated login to fetch Users entity and use new token generation |
| `ticket-service/.../security/JwtUtil.java` | **CRITICAL**: Changed secret key decoding from UTF-8 to BASE64 |

---

## Testing

### 1. Login and Get Token
```bash
curl -X POST http://localhost:8080/auth/users/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@example.com","password":"password123"}'
```

Response:
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjUsInJvbGVzIjpbIkFETUlOIl0sInN1YiI6ImFkbWluQGV4YW1wbGUuY29tIiwiaWF0IjoxNzY1MzYzNjI5LCJleHAiOjE3NjUzNjU0Mjl9.1nXX0HJdsUOZB1wQC_Hcs8Whh8bLIFP58t4gYvVjliM",
  "tokenType": "Bearer",
  "expireId": 1800
}
```

### 2. Decode Token at jwt.io
**Header:**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Payload:**
```json
{
  "userId": 5,
  "roles": ["ADMIN"],
  "sub": "admin@example.com",
  "iat": 1765363629,
  "exp": 1765365429
}
```

### 3. Access Protected Endpoint (SHOULD NOW WORK)
```bash
curl -X GET http://localhost:8080/ticket/tickets \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjUsInJvbGVzIjpbIkFETUlOIl0sInN1YiI6ImFkbWluQGV4YW1wbGUuY29tIiwiaWF0IjoxNzY1MzYzNjI5LCJleHAiOjE3NjUzNjU0Mjl9.1nXX0HJdsUOZB1wQC_Hcs8Whh8bLIFP58t4gYvVjliM"
```

**Expected Response:** 200 OK with ticket list ✓

---

## Key Learnings

1. **JWT Secret Encoding Matters**: The secret is base64-encoded. All services must decode it the same way when verifying signatures.
2. **Consistent Cryptography**: Sign and verify must use identical key derivation, or signature verification always fails.
3. **Role Claims Required**: Any service checking authorization needs roles/authorities in the token payload.
4. **Multi-Service JWT**: When JWT is used across multiple services, use a shared utility or ensure identical configuration.

---

## Summary

The 403 Forbidden was caused by **two issues working together**:
1. Missing `roles` claim in JWT token (authorization checks had no roles to verify)
2. Different secret key decoding in ticket-service (signature verification failed before authorization could even be checked)

Both issues have been fixed. The JWT now includes roles, and both services use BASE64 decoding for the secret key, so signature verification succeeds and authorization checks can proceed.

